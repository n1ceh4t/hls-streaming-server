import fs from 'fs/promises';
import path from 'path';
import { createLogger } from '../../utils/logger';
import { AsyncMutex } from '../../utils/AsyncMutex';

const logger = createLogger('PlaylistService');

/**
 * PlaylistService - serves FFmpeg playlists with bumper segment injection during transitions
 *
 * Since we re-encode all files to identical parameters:
 * - Same codec (libx264), resolution, bitrate, frame rate, GOP structure
 * - Timestamps reset with genpts/avoid_negative_ts
 * - No discontinuity tags needed - all segments have identical encoding parameters
 *
 * During transitions (file ended, waiting for next file), injects pre-generated bumper segments
 * to bridge the gap and ensure seamless playback.
 *
 * Thread Safety:
 * - Uses per-channel mutexes to prevent concurrent playlist modifications
 * - Prevents race conditions between client requests and FFmpeg operations
 */
export class PlaylistService {
  // @ts-ignore - Temporarily unused in debug mode
  private channelService?: any; // ChannelService - injected via setter to avoid circular dependency

  // Per-channel mutexes for playlist operations (prevents read-modify-write races)
  private playlistMutexes: Map<string, AsyncMutex> = new Map();

  /**
   * Set ChannelService reference (called by ChannelService constructor)
   */
  setChannelService(channelService: any): void {
    this.channelService = channelService;
  }

  /**
   * Get or create mutex for a channel
   */
  private getMutexForChannel(channelId: string): AsyncMutex {
    let mutex = this.playlistMutexes.get(channelId);
    if (!mutex) {
      mutex = new AsyncMutex();
      this.playlistMutexes.set(channelId, mutex);
    }
    return mutex;
  }

  /**
   * Get playlist content for a channel
   * 
   * Reads FFmpeg's playlist file, removes any discontinuity tags, and returns it.
   * All files are re-encoded to identical parameters, so discontinuity tags are not needed.
   * 
   * @param playlistPath - Path to FFmpeg's playlist file (stream.m3u8)
   * @param channelId - Channel ID for logging (optional, extracted from path if not provided)
   * @param returnOriginal - If true, returns original playlist without modifications (for debugging)
   * @returns Playlist content as generated by FFmpeg, or minimal valid fallback
   */
  // @ts-ignore - returnOriginal parameter temporarily unused in debug mode
  async getPlaylist(playlistPath: string, channelId?: string, _returnOriginal: boolean = false): Promise<string> {
    // Extract channelId for logging if not provided (no lock needed for this)
    const actualChannelId = channelId || this.extractChannelIdFromPath(playlistPath);

    // CRITICAL: Use mutex to prevent concurrent playlist operations for the same channel
    // This prevents:
    // 1. Multiple bumper injections from simultaneous client requests
    // 2. Race conditions between client reads and FFmpeg writes
    // 3. Corrupted playlists from concurrent modifications
    const mutex = actualChannelId ? this.getMutexForChannel(actualChannelId) : new AsyncMutex();

    return await mutex.runExclusive(async () => {
      try {
        // Read FFmpeg's playlist from disk
        const content = await fs.readFile(playlistPath, 'utf-8');
      
        // Validate it's a valid M3U8 file
        if (!content.includes('#EXTM3U')) {
          logger.warn(
            { playlistPath, contentPreview: content.substring(0, 200) },
            'Invalid M3U8 file - missing #EXTM3U header, returning minimal playlist'
          );
          return this.buildMinimalPlaylist();
        }

        // TEMPORARY DEBUG: Return original playlist without modifications
        logger.debug(
          {
            playlistPath,
            channelId: actualChannelId || 'unknown',
            segmentCount: (content.match(/\.ts/g) || []).length
          },
          'Returning original playlist (DEBUG MODE - no modifications)'
        );
        return content;
        
        // DISABLED FOR DEBUG - Original processing code below:
        /*
        // Check if channel is in transition (file ended, waiting for next file)
        // If so, inject pre-generated bumper segments to bridge the gap
        if (actualChannelId && this.channelService) {
          const transitionState = await this.channelService.getTransitionState(actualChannelId);
          if (transitionState?.bumperInfo) {
            // Only inject if not already injected (prevents multiple injections during wait period)
            if (!transitionState.bumperInjected) {
              const injectedPlaylist = await this.injectBumperSegments(playlistPath, actualChannelId, transitionState.bumperInfo);
              // Mark as injected to prevent re-injection on subsequent playlist requests
              await this.channelService.markBumperAsInjected(actualChannelId);
              return injectedPlaylist;
            } else {
              // Bumper already injected - just read and return the playlist from disk
              logger.debug({ channelId: actualChannelId }, 'Bumper already injected, returning playlist from disk');
            }
          }
        }
      
        // Remove discontinuity tags - all files are re-encoded to identical parameters
        // Discontinuity tags confuse Roku when segments don't actually have different encoding
        let cleanedContent = content.replace(/#EXT-X-DISCONTINUITY\n/g, '');
        const hadDiscontinuities = cleanedContent.length !== content.length;
        
        // Also remove EXT-X-DISCONTINUITY-SEQUENCE if present (not needed without discontinuities)
        cleanedContent = cleanedContent.replace(/#EXT-X-DISCONTINUITY-SEQUENCE:\d+\n/g, '');
        
        if (hadDiscontinuities) {
          logger.debug(
            {
              playlistPath,
              channelId: actualChannelId || 'unknown',
              segmentCount: (cleanedContent.match(/\.ts/g) || []).length
            },
            'Removed discontinuity tags from playlist (all segments have identical encoding parameters)'
          );
        }
        
        logger.debug(
          {
            playlistPath,
            contentLength: cleanedContent.length,
            segmentCount: (cleanedContent.match(/\.ts/g) || []).length,
            channelId: actualChannelId || 'unknown'
          },
          'Served FFmpeg playlist (all files re-encoded to identical parameters, no discontinuity tags needed)'
        );
        
        // Return cleaned playlist - all segments have identical encoding parameters
        return cleanedContent;
        */
      
      } catch (error) {
        const fsError = error as NodeJS.ErrnoException;

        // Playlist doesn't exist yet (normal during initialization)
        if (fsError.code === 'ENOENT') {
          logger.debug(
            { playlistPath },
            'Playlist file not found (FFmpeg still initializing), returning minimal playlist'
          );
          return this.buildMinimalPlaylist();
        }

        // Other errors
        logger.error(
          { error, playlistPath, errorCode: fsError.code },
          'Error reading playlist file, returning minimal playlist'
        );

        return this.buildMinimalPlaylist();
      }
    }); // End of mutex.runExclusive()
  }

  /**
   * Build minimal valid EVENT playlist for error/initialization cases
   * 
   * This prevents player errors when FFmpeg hasn't created the playlist yet.
   * Players will retry and eventually get the real playlist once FFmpeg starts.
   */
  private buildMinimalPlaylist(): string {
    return `#EXTM3U
#EXT-X-VERSION:6
#EXT-X-ALLOW-CACHE:NO
#EXT-X-TARGETDURATION:6
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-INDEPENDENT-SEGMENTS
#EXT-X-PLAYLIST-TYPE:EVENT
`;
  }

  /**
   * Extract channel ID from playlist path
   * 
   * Attempts to extract channelId from the playlist path structure.
   * Falls back to using the directory name as channelId.
   * 
   * @param playlistPath - Full path to playlist file
   * @returns Extracted channel ID or undefined
   */
  private extractChannelIdFromPath(playlistPath: string): string | undefined {
    try {
      // Playlist path structure: .../hls_output/{channelId}/stream.m3u8
      // or: .../{channelId}/stream.m3u8
      const dir = path.dirname(playlistPath);
      const channelId = path.basename(dir);
      return channelId || undefined;
    } catch {
      return undefined;
    }
  }

  /**
   * Inject pre-generated bumper segments into playlist during transition
   * 
   * When file1 ends and file2 hasn't started yet, we inject bumper segments
   * to bridge the gap. Segment numbering continues from the last segment in the playlist.
   * 
   * @param playlistPath - Path to existing playlist file
   * @param channelId - Channel ID
   * @param bumperInfo - Bumper segment directory and count
   * @returns Modified playlist with bumper segments injected
   */
  // @ts-ignore - Temporarily unused in debug mode
  private async injectBumperSegments(
    playlistPath: string,
    channelId: string,
    bumperInfo: { segmentsDir: string; segmentCount: number }
  ): Promise<string> {
    try {
      // Read existing playlist to get last segment number
      let existingContent = '';
      let lastSegmentNumber = -1;
      let mediaSequence = 0;
      let targetDuration = 15; // Default to 15 seconds
      
      try {
        existingContent = await fs.readFile(playlistPath, 'utf-8');
        
        // Extract MEDIA-SEQUENCE
        const mediaSeqMatch = existingContent.match(/#EXT-X-MEDIA-SEQUENCE:(\d+)/);
        if (mediaSeqMatch) {
          mediaSequence = parseInt(mediaSeqMatch[1], 10);
        }
        
        // Extract TARGETDURATION
        const targetDurMatch = existingContent.match(/#EXT-X-TARGETDURATION:(\d+)/);
        if (targetDurMatch) {
          targetDuration = parseInt(targetDurMatch[1], 10);
        }
        
        // Find last segment number
        const segments = existingContent.match(/stream_(\d+)\.ts/g) || [];
        if (segments.length > 0) {
          const lastSegMatch = segments[segments.length - 1].match(/stream_(\d+)\.ts/);
          if (lastSegMatch) {
            lastSegmentNumber = parseInt(lastSegMatch[1], 10);
          }
        }
      } catch {
        // Playlist might not exist or be empty - start from 0
        logger.debug({ channelId }, 'No existing playlist found, starting bumper segments from 0');
      }
      
      // Read bumper segment files
      const bumperFiles = await fs.readdir(bumperInfo.segmentsDir);
      const bumperSegments = bumperFiles
        .filter(f => f.endsWith('.ts') && f.startsWith('bumper_'))
        .sort(); // Sort to ensure correct order
      
      if (bumperSegments.length === 0) {
        logger.warn({ channelId, segmentsDir: bumperInfo.segmentsDir }, 'No bumper segments found, returning existing playlist');
        return existingContent || this.buildMinimalPlaylist();
      }
      
      // Build playlist with bumper segments
      // Start segment numbering from lastSegmentNumber + 1
      let nextSegmentNumber = lastSegmentNumber + 1;
      
      // Get existing playlist lines
      const existingLines = existingContent.split('\n');
      const headerLines: string[] = [];
      const segmentLines: string[] = [];
      let inSegments = false;

      for (const line of existingLines) {
        if (line.startsWith('#EXT')) {
          if (line.startsWith('#EXTINF') || line.startsWith('#EXT-X-PROGRAM-DATE-TIME')) {
            inSegments = true;
            segmentLines.push(line);
          } else if (!inSegments) {
            // Skip discontinuity tags - they'll be removed by getPlaylist()
            if (!line.startsWith('#EXT-X-DISCONTINUITY')) {
              headerLines.push(line);
            }
          }
        } else if (line.trim()) {
          if (inSegments && line.includes('.ts')) {
            segmentLines.push(line);
          } else if (!inSegments) {
            headerLines.push(line);
          }
        }
      }

      // Build new playlist: keep headers, add bumper segments
      const newPlaylist: string[] = [];

      // Add headers (or build minimal if none exist)
      if (headerLines.length > 0 && headerLines.some(l => l.includes('#EXTM3U'))) {
        newPlaylist.push(...headerLines.filter(l => !l.includes('MEDIA-SEQUENCE')));
        // Update MEDIA-SEQUENCE to account for bumper segments
        newPlaylist.push(`#EXT-X-MEDIA-SEQUENCE:${mediaSequence}`);
      } else {
        // Build minimal header
        newPlaylist.push(
          '#EXTM3U',
          '#EXT-X-VERSION:3',
          '#EXT-X-ALLOW-CACHE:NO',
          `#EXT-X-TARGETDURATION:${targetDuration}`,
          `#EXT-X-MEDIA-SEQUENCE:${mediaSequence}`
        );
      }

      // Add existing segments (keep last few for continuity)
      // Segments come in pairs: #EXTINF + .ts filename (and optional #EXT-X-PROGRAM-DATE-TIME)
      const keepLastSegments = 5; // Keep last 5 segments from previous file
      const segmentPairs: string[][] = [];
      let currentPair: string[] = [];

      for (const line of segmentLines) {
        currentPair.push(line);
        if (line.includes('.ts')) {
          segmentPairs.push(currentPair);
          currentPair = [];
        }
      }

      if (segmentPairs.length > 0) {
        const pairsToKeep = segmentPairs.slice(-keepLastSegments);
        for (const pair of pairsToKeep) {
          newPlaylist.push(...pair);
        }
        // Update nextSegmentNumber based on last kept segment
        const lastPair = pairsToKeep[pairsToKeep.length - 1];
        const tsLine = lastPair.find(l => l.includes('.ts'));
        if (tsLine) {
          const match = tsLine.match(/stream_(\d+)\.ts/);
          if (match) {
            nextSegmentNumber = parseInt(match[1], 10) + 1;
          }
        }
      }
      
      // Add bumper segments with correct numbering
      // Bumper segments are served from the bumper directory, but referenced with stream_XXX.ts naming
      const outputDir = path.dirname(playlistPath);
      const segmentDuration = targetDuration; // Use target duration from playlist

      // Calculate program date time for bumper segments
      // Start from the last segment's timestamp if available
      let bumperTimestamp = Date.now();
      if (segmentPairs.length > 0) {
        const lastPair = segmentPairs[segmentPairs.length - 1];
        const dateTimeLine = lastPair.find(l => l.startsWith('#EXT-X-PROGRAM-DATE-TIME:'));
        if (dateTimeLine) {
          const timestamp = new Date(dateTimeLine.replace('#EXT-X-PROGRAM-DATE-TIME:', '')).getTime();
          // Add the last segment's duration to get the bumper start time
          bumperTimestamp = timestamp + (segmentDuration * 1000);
        }
      }

      for (let i = 0; i < bumperSegments.length; i++) {
        const bumperFile = bumperSegments[i];
        const bumperPath = path.join(bumperInfo.segmentsDir, bumperFile);
        const segmentNumber = nextSegmentNumber + i;
        const segmentName = `stream_${segmentNumber.toString().padStart(3, '0')}.ts`;

        // Copy bumper segment to output directory with correct name
        // This allows FFmpeg's append_list to continue from the correct segment number
        const outputSegmentPath = path.join(outputDir, segmentName);
        try {
          await fs.copyFile(bumperPath, outputSegmentPath);
        } catch (error) {
          logger.warn({ channelId, bumperPath, outputSegmentPath, error }, 'Failed to copy bumper segment, continuing');
        }

        // Add segment to playlist with program date time for consistency
        const bumperDate = new Date(bumperTimestamp + (i * segmentDuration * 1000));
        const isoTimestamp = bumperDate.toISOString().replace('Z', '-0600'); // Match FFmpeg's timezone format
        newPlaylist.push(`#EXTINF:${segmentDuration.toFixed(6)},`);
        newPlaylist.push(`#EXT-X-PROGRAM-DATE-TIME:${isoTimestamp}`);
        newPlaylist.push(segmentName);
      }
      
      const finalPlaylist = newPlaylist.join('\n') + '\n';

      // CRITICAL: Write injected playlist to disk so FFmpeg sees it with append_list
      // Otherwise FFmpeg reads the old playlist, doesn't see the bumper, and overwrites the bumper segment!
      try {
        await fs.writeFile(playlistPath, finalPlaylist);
        logger.info({ channelId, playlistPath }, 'Wrote bumper-injected playlist to disk for FFmpeg');
      } catch (err) {
        logger.error({ channelId, err, playlistPath }, 'Failed to write bumper playlist to disk - FFmpeg may overwrite bumper!');
      }

      // DEBUG: Write playlist to file
      try {
        const debugPath = `/tmp/playlist_injected_${channelId}_${Date.now()}.out`;
        await fs.writeFile(debugPath, finalPlaylist);
        logger.info({ channelId, debugPath }, 'Wrote injected playlist to debug file');
      } catch (err) {
        logger.warn({ channelId, err }, 'Failed to write debug playlist');
      }

      logger.info(
        {
          channelId,
          bumperSegmentsCount: bumperSegments.length,
          firstSegmentNumber: nextSegmentNumber,
          lastSegmentNumber: nextSegmentNumber + bumperSegments.length - 1,
          mediaSequence
        },
        'Injected bumper segments into playlist during transition'
      );

      return finalPlaylist;
      
    } catch (error) {
      logger.error(
        { error, channelId, playlistPath, bumperInfo },
        'Failed to inject bumper segments, returning existing playlist'
      );
      
      // Fallback: return existing playlist or minimal
      try {
        return await fs.readFile(playlistPath, 'utf-8');
      } catch {
        return this.buildMinimalPlaylist();
      }
    }
  }
}

