import fs from 'fs/promises';
import path from 'path';
import { createLogger } from '../../utils/logger';

const logger = createLogger('PlaylistService');

/**
 * Simplified PlaylistService for the new playback pipeline
 * 
 * New Pipeline (Sequential Streaming with FFmpeg Built-in Discontinuity Handling):
 * ================================================================================
 * File1 ends → Bumper streams (separate FFmpeg) → File2 starts
 * 
 * Key Changes:
 * - Each media file is a separate FFmpeg process
 * - Bumpers stream independently between files (no playlist merging)
 * - PlaylistService just serves FFmpeg's playlist directly (no modification!)
 * - FFmpeg is the source of truth for segments, MEDIA-SEQUENCE, and DISCONTINUITY tags
 * - FFmpeg's discont_start flag automatically handles EXT-X-DISCONTINUITY tags at transitions
 * 
 * What We Do:
 * - Read FFmpeg's playlist and return it as-is (FFmpeg handles discontinuity tags)
 * - Handle missing/empty playlist gracefully (return minimal valid playlist)
 * 
 * What We DON'T Do Anymore:
 * - ❌ Merge bumper segments into playlists
 * - ❌ Scan disk for all segments
 * - ❌ Manage MEDIA-SEQUENCE manually
 * - ❌ Inject discontinuity tags manually (FFmpeg does this automatically!)
 * - ❌ Track transition points
 * - ❌ Modify playlists on-read
 */
export class PlaylistService {

  /**
   * Get playlist content for a channel
   * 
   * Reads FFmpeg's playlist file and returns it as-is.
   * FFmpeg's discont_start flag automatically handles EXT-X-DISCONTINUITY tags.
   * 
   * @param playlistPath - Path to FFmpeg's playlist file (stream.m3u8)
   * @param channelId - Channel ID for logging (optional, extracted from path if not provided)
   * @returns Playlist content as generated by FFmpeg, or minimal valid fallback
   */
  async getPlaylist(playlistPath: string, channelId?: string): Promise<string> {
    try {
      // Read FFmpeg's playlist and return as-is
      const content = await fs.readFile(playlistPath, 'utf-8');
      
      // Validate it's a valid M3U8 file
      if (!content.includes('#EXTM3U')) {
        logger.warn(
          { playlistPath, contentPreview: content.substring(0, 200) },
          'Invalid M3U8 file - missing #EXTM3U header, returning minimal playlist'
        );
        return this.buildMinimalPlaylist();
      }
      
      // Extract channelId for logging if not provided
      const actualChannelId = channelId || this.extractChannelIdFromPath(playlistPath);
      
      logger.debug(
        {
          playlistPath,
          contentLength: content.length,
          segmentCount: (content.match(/\.ts/g) || []).length,
          discontinuityCount: (content.match(/#EXT-X-DISCONTINUITY/g) || []).length,
          channelId: actualChannelId || 'unknown'
        },
        'Served FFmpeg playlist (FFmpeg handles discontinuity tags automatically)'
      );
      
      // Return playlist as-is - FFmpeg handles all discontinuity tags
      return content;
      
    } catch (error) {
      const fsError = error as NodeJS.ErrnoException;
      
      // Playlist doesn't exist yet (normal during initialization)
      if (fsError.code === 'ENOENT') {
        logger.debug(
          { playlistPath },
          'Playlist file not found (FFmpeg still initializing), returning minimal playlist'
        );
        return this.buildMinimalPlaylist();
      }
      
      // Other errors
      logger.error(
        { error, playlistPath, errorCode: fsError.code },
        'Error reading playlist file, returning minimal playlist'
      );
      
      return this.buildMinimalPlaylist();
    }
  }

  /**
   * Build minimal valid EVENT playlist for error/initialization cases
   * 
   * This prevents player errors when FFmpeg hasn't created the playlist yet.
   * Players will retry and eventually get the real playlist once FFmpeg starts.
   */
  private buildMinimalPlaylist(): string {
    return `#EXTM3U
#EXT-X-VERSION:6
#EXT-X-ALLOW-CACHE:NO
#EXT-X-TARGETDURATION:6
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-INDEPENDENT-SEGMENTS
#EXT-X-PLAYLIST-TYPE:EVENT
`;
  }

  /**
   * Extract channel ID from playlist path
   * 
   * Attempts to extract channelId from the playlist path structure.
   * Falls back to using the directory name as channelId.
   * 
   * @param playlistPath - Full path to playlist file
   * @returns Extracted channel ID or undefined
   */
  private extractChannelIdFromPath(playlistPath: string): string | undefined {
    try {
      // Playlist path structure: .../hls_output/{channelId}/stream.m3u8
      // or: .../{channelId}/stream.m3u8
      const dir = path.dirname(playlistPath);
      const channelId = path.basename(dir);
      return channelId || undefined;
    } catch {
      return undefined;
    }
  }
}

